def sum_n(n):  #:가 중괄호 역할이다
	s = 0
	for i in range(1,n+1):
		s = s + i
	return s;
	
	
print(sum_n(10)) #55
print(sum_n(100)) #5050

def sum_n_v2(n): #등차수열 공식 이용한 version
	return n*(n+1)/2
	
print(sum_n_v2(10)) #55.0
print(sum_n_v2(100)) #5050.0

#소숫점 버리기 참고 : https://dpdpwl.tistory.com/94

print(round(sum_n_v2(10))) #55
print(round(sum_n_v2(100))) #5050

#big O 표기법
#계산 복잡도를 표현하는 대표적인 방법. 입력크기에 대한 계산횟수의 비례관계에 따라 표현이 달라짐.

#연습문제 1-1 1~n까지 연속한 숫자의 제곱의 합을 구하는 프로그램을 for 반복문으로 만들기

def sum_Of_pow(n):
	result = 0
	for i in range(1,n+1):
		result = result + i*i
	return result;
		
print(sum_Of_pow(10)) #385 #return 들여쓰기 하나만 잘못해도 for 함수 안으로 인식된다 조심!!

#연습문제 1-2 연습문제 1-1 계산복잡도는..? n이 증가함에 따라 n만큼의 횟수의 반복이 필요하므로 O(n)이다
#연습문제 1-3 ~~ 공식에 n의 3제곱이 있더라도 n 이 주어진 상황에서서 계산은 한 번에 끝나므로 입력값에 따라 계산 복잡도가 변하지 않음. 따라서 O(1)


#프로그램 2-1 최댓값 구하기
def find_max(a):

    n = len(a)             # 입력 크기 n

    max_v = a[0]           # 리스트의 첫 번째 값을 최댓값으로 기억

    for i in range(1, n):  # 1부터 n -1까지 반복

        if a[i] > max_v:   # 이번 값이 현재까지 기억된 최댓값보다 크면

            max_v = a[i]   # 최댓값을 변경

    return max_v
	
v1 = [17, 92, 18, 33, 58, 7, 33, 42]

print(find_max(v1))
	
	#2-2 최댓값의 인덱스 구하기
def find_max_idx(a):

    n = len(a)                 # 입력 크기 n

    max_idx = 0                # 리스트 중 0번 위치를 최댓값 위치로 기억

    for i in range(1, n):

        if a[i] > a[max_idx]:  # 이번 값이 현재까지 기억된 최댓값보다 크면

            max_idx = i        # 최댓값의 위치를 변경

    return max_idx

 

v2 = [17, 92, 18, 33, 58, 7, 33, 42]

print(find_max_idx(v2))


#프로그램 3-1 동명이인 찾기

def find_same_name(a):

    n = len(a)                     # 리스트의 자료 개수를 n에 저장

    result = set()                 # 결과를 저장할 빈 집합

    for i in range(0, n -1):       # 0부터 n -2까지 반복

        for j in range(i + 1, n):  # i+1부터 n -1까지 반복

            if a[i] == a[j]:      # 이름이 같으면

                result.add(a[i])   # 찾은 이름을 result에 추가

    return result

 

name = ["Tom", "Jerry", "Mike", "Tom"] # 대소문자 유의: 파이썬은 대소문자를 구분함

print(find_same_name(name))

name2 = ["Tom", "Jerry", "Mike", "Tom", "Mike"]

print(find_same_name(name2))


#이중 반복문을 쓸 경우 어지간해선 O(n^2)을 피하기가 힘들어보인다. 코드가 특별히 간결해지는 경우를 제외하고는 다른 방법을 쓰는 것이 좋겠다.

#연습문제 3-1

def comp(n):
	le = len(n)
	
	for i in range(1,le):
		for j in range(i+1, le):
			if n[i] == n[j]:
				print(n[i],"-",n[j])
	

	
print(comp(["Tom", "Jerry", "Mike"]))

#모법답안
def print_pairs(a):

    n = len(a)                     # 리스트의 자료 개수를 n에 저장

    for i in range(0, n - 1):      # 0부터 n - 2까지 반복

        for j in range(i + 1, n):  # i + 1부터 n - 1까지 반복

            print(a[i], "-", a[j])

 

name = ["Tom", "Jerry", "Mike"]

print_pairs(name)

print()

name2 = ["Tom", "Jerry", "Mike", "John"]

print_pairs(name2)

